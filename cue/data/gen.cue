package grafanaschema

dashboardFamily: #SchemaFamily & {
	Kind: "grafanaDashboard"
	seqs: [
		[ // 0.0
			// Base dashboard schema.
			{
				// Unique numeric identifier for the dashboard.
				// TODO must isolate or remove identifiers local to a Grafana instance...?
				id?: int
				// Unique dashboard identifier that can be generated by anyone. string (8-40)
				uid?: string
				// Title of dashboard.
				title?: string
				// Description of dashboard.
				description?: string
				// Tags associated with dashboard.
				tags?: [...string]
				// Theme of dashboard.
				style: *"light" | "dark"
				// Timezone of dashboard,
				timezone?: *"browser" | "utc"
				// Whether a dashboard is editable or not.
				editable: bool | *true
				// 0 for no shared crosshair or tooltip (default).
				// 1 for shared crosshair.
				// 2 for shared crosshair AND shared tooltip.
				graphTooltip: int >= 0 <= 2 | *0
				// Time range for dashboard, e.g. last 6 hours, last 7 days, etc
				time?: {
					from: string | *"now-6h"
					to:   string | *"now"
				}
				// Timepicker metadata.
				timepicker?: {
					// Whether timepicker is collapsed or not.
					collapse: bool | *false
					// Whether timepicker is enabled or not.
					enable: bool | *true
					// Whether timepicker is visible or not.
					hidden: bool | *false
					// Selectable intervals for auto-refresh.
					refresh_intervals: [...string] | *["5s", "10s", "30s", "1m", "5m", "15m", "30m", "1h", "2h", "1d"]
				}
				// Templating.
				templating?: list: [...{...}]
				// Annotations.
				annotations?: list: [...{
					builtIn: int | *0
					// Datasource to use for annotation.
					datasource: string
					// Whether annotation is enabled.
					enable?: bool | *true
					// Whether to hide annotation.
					hide?: bool | *false
					// Annotation icon color.
					iconColor?: string
					// Name of annotation.
					name?: string
					// Query for annotation data.
					rawQuery: string
					showIn:   int | *0
				}] | *[]
				// Auto-refresh interval.
				refresh: string
				// Version of the JSON schema, incremented each time a Grafana update brings
				// changes to said schema.
				schemaVersion: int | *25
				// Version of the dashboard, incremented each time the dashboard is updated.
				version: string
                // Dashboard panels. Panels are canonically defined inline
                // because they share a version timeline with the dashboard
                // schema; they do not vary independently. We create a separate,
                // synthetic Family to represent them in Go.
				panels?: [...{
                    // The panel plugin type id. 
                    type: !=""

                    // Panel title.
                    title?: string
                    // Description.
                    description?: string
                    // Whether to display the panel without a background.
                    transparent: bool | *false
                    // Name of default datasource.
                    datasource?: string
                    // Grid position.
                    gridPos?: {
						// Panel height.
						h: int > 0 | *9
						// Panel width.
						w: int > 0 <= 24 | *12
						// Panel x position.
						x: int >= 0 < 24 | *0
						// Panel y position.
						y: int >= 0 | *0
						// true if fixed
						static?: bool
					}
                    // Panel links.
                    // links?: [..._panelLink]
                    // Name of template variable to repeat for.
                    repeat?: string
                    // Direction to repeat in if 'repeat' is set.
                    // "h" for horizontal, "v" for vertical.
                    repeatDirection: *"h" | "v"
                    // Schema for panel targets is specified by datasource
                    // plugins. We use a placeholder definition, which the Go
                    // schema loader either left open/as-is with the Base
                    // variant of the Dashboard and Panel families, or filled
                    // with types derived from plugins in the Instance variant.
                    // When working directly from CUE, importers can extend this
                    // type directly to achieve the same effect.
                    targets?: [...{}]

                    // The values depend on panel type
                    options: {}

                    fieldConfig: {
						defaults: {
							// The display value for this field. This supports
							// template variables blank is auto
							displayName?: string

							// This can be used by data sources that return and
							// explicit naming structure for values and labels
							// When this property is configured, this value is
							// used rather than the default naming strategy.
							displayNameFromDS?: string

							// Human readable field metadata
							description?: string

							// An explict path to the field in the datasource.  When the frame meta includes a path,
							// This will default to `${frame.meta.path}/${field.name}
							//
							// When defined, this value can be used as an
							// identifier within the datasource scope, and may
							// be used to update the results
							path?: string

							// True if data source can write a value to the
							// path. Auth/authz are supported separately
							writeable?: bool

							// True if data source field supports ad-hoc filters
							filterable?: bool

							// Numeric Options
							unit?: string

							// Significant digits (for display)
							decimals?: number | *null

							min?: number | null
							max?: number | null

							// Alternative to empty string
							noValue?: string

							// Panel Specific Values
							custom?: {} // Can cuetsy make this generic? <T = any>
						}
						// Rules to override individual values.
						// TODO specify this a bit more, even though it's complicated
						overrides: [...{}]
					}
                }]
            }
		]
	]
}

#Latest: {
    #Dashboard: dashboardFamily.latest.Dashboard
    #Panel: dashboardFamily.latest.Panel
}

// A Schema is an individual specification for some kind of object or data. It
// is expected to be contained in a #Seq, which is contained in a #SchemaFamily.
//
// TODO finalize placement of Migration, then integrate into Seq.
#Schema: {
    S: {...}
    // TODO optional? How do we deal with first #Schema in a #Seq?
    M: #Migration
}

// A Seq is a series of schemas that all describe a single kind of object.
// TODO use #Schema
// TODO different type for v0 that doesn't entail backwards compatibility?
#Seq: [{...}, ...{...}]
#LastSchema: {
    _p: #Seq
    _p[len(_p)-1]
}

#SchemaFamily: {
    // Kind is the canonical name of the object that all schemata in the Family
    // describe.
    Kind: string

    // TODO This encodes the idea that schemata are organized into a series of
    // (backwards compatible) lineage sequences, with major and minor versions
    // corresponding to their position in the series of arrays. (i.e. the
    // first schema in the first lineage is 0.0.)
    // This approach can, and probably should, change. However, any approach 
    // will need to maintain certain properties: 
    //  - Specific versions of a schema can be extracted by querying the family
    //    with version number
    //  - (Probably) individual schema do not internally define
    //    version fields, but instead rely on this SchemaFamily meta-structure to do it
	seqs: [#Seq, ...#Seq]
	let lseq = seqs[len(seqs)-1]
	latest: #LastSchema & { _p: lseq }

    // Enforce that schemata within a seq are backwards compatible.
    _bccheck: {
        for ov, seq in seqs {
            for iv, schema in seq if iv > 0 {
                // Key the check on the schema being checked
                "\(ov).\(iv)": seq[iv-1] & close(schema)
                // TODO either here or in another loop, automatically create migrations
                // for 
            }
        }
    }
}

// A Migration defines a relation between two schemata, "_from" and "_to". The
// relation expresses any complex mappings that must be performed to
// transform an input artifact valid with respect to the _from schema, into
// an artifact valid with respect to the _to schema. This is accomplished
// in two stages:
//   1. A Migration is initially defined by passing in schemata for _from and _to,
//      and mappings that translate _from to _to are defined in _rel. 
//   2. A concrete object may then be unified with _to, resulting in its values
//      being mapped onto "output" by way of _rel.
//
// This is the absolute simplest possible definition of a Migration. It's
// incumbent on the implementor to manually ensure the correctness and
// completeness of the mapping. The primary value in defining a generic
// structure for this is to allow similarly generic logic for pushing
// concrete artifacts through schema changes.
//
// If _to isn't backwards compatible (accretion-only) with _from, then _rel must
// explicitly enumerate every field in _from and map it to a field in _to, even
// if they're identical. This is laborious for anything outside trivially tiny
// schema. We'll want to eventually add helpers for whitelisting or blacklisting
// of paths in _from, so that migrations of larger schema can focus narrowly on
// the points of actual change.
#Migration: {
    _from: {...}
    _to: {...}
    _rel: {...}
    output: _to & _rel
}