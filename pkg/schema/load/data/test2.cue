package grafanaschematest2

dashboardFamily2: #SchemaFamily & {
	seqs: [
		[ // 0.0
			{
                // Base dashboard schema.
                Dashboard: {
                    // Unique numeric identifier for the dashboard.
                    // TODO must isolate or remove identifiers local to a Grafana instance...?
                    id: int
                    // Unique dashboard identifier that can be generated by anyone. string (8-40)
                    uid: string
                    // Title of dashboard.
                    title?: string
                    // Description of dashboard.
                    description?: string
                    // Tags associated with dashboard.
                    tags?: [...string]
                    // Theme of dashboard.
                    style: *"light" | "dark"
                    // Timezone of dashboard,
                    timezone?: *"browser" | "utc"
                    // Whether a dashboard is editable or not.
                    editable: bool | *true
                    // 0 for no shared crosshair or tooltip (default).
                    // 1 for shared crosshair.
                    // 2 for shared crosshair AND shared tooltip.
                    graphTooltip: int & >=0 & <=2 | *0
                    // Time range for dashboard, e.g. last 6 hours, last 7 days, etc
                    time?: {
                        from: string | *"now-6h"
                        to:   string | *"now"
                    }
                    // Timepicker metadata.
                    timepicker?: {
                        // Whether timepicker is collapsed or not.
                        collapse: bool | *false
                        // Whether timepicker is enabled or not.
                        enable: bool | *true
                        // Whether timepicker is visible or not.
                        hidden: bool | *false
                        // Selectable intervals for auto-refresh.
                        refresh_intervals: [...string] | *["5s", "10s", "30s", "1m", "5m", "15m", "30m", "1h", "2h", "1d"]
                    }
                    // Templating.
                    templating?: list: [...{...}]
                    // Annotations.
                    annotations?: list: [...{
                        builtIn: int | *0
                        // Datasource to use for annotation.
                        datasource: string
                        // Whether annotation is enabled.
                        enable?: bool | *true
                        // Whether to hide annotation.
                        hide?: bool | *false
                        // Annotation icon color.
                        iconColor?: string
                        // Name of annotation.
                        name?: string
                        // Query for annotation data.
                        rawQuery: string
                        showIn:   int | *0
                    }] | *[]
                    // Auto-refresh interval.
                    refresh: string
                    // Version of the JSON schema, incremented each time a Grafana update brings
                    // changes to said schema.
                    schemaVersion: int | *25
                    // Version of the dashboard, incremented each time the dashboard is updated.
                    version: string
                    panels?: [...Panel]
                }
                // Dashboard panels. Panels are canonically defined inline
                // because they share a version timeline with the dashboard
                // schema; they do not vary independently. We create a separate,
                // synthetic Family to represent them in Go.
                Panel: {
                    // The panel plugin type id. 
                    type: !=""

                    // Panel title.
                    title?: string
                    // Description.
                    description?: string
                    // Whether to display the panel without a background.
                    transparent: bool | *false
                    // Name of default datasource.
                    datasource?: string
                    // Grid position.
                    gridPos?: PanelGridPos
                    // Panel links.
                    // links?: [..._panelLink]
                    // Name of template variable to repeat for.
                    repeat?: string
                    // Direction to repeat in if 'repeat' is set.
                    // "h" for horizontal, "v" for vertical.
                    repeatDirection: *"h" | "v"
                    // Schema for panel targets is specified by datasource
                    // plugins. We use a placeholder definition, which the Go
                    // schema loader either left open/as-is with the Base
                    // variant of the Dashboard and Panel families, or filled
                    // with types derived from plugins in the Instance variant.
                    // When working directly from CUE, importers can extend this
                    // type directly to achieve the same effect.
                    targets?: [...{}]

                    // The values depend on panel type
                    options: {}

                    // TODO This references a type defined outside the Family
                    // decl. This probably isn't OK at all, because it means we
                    // won't have snapshots of the historical versions of
                    // FieldConfig, which makes it impossible to guarantee
                    // immutability of historical schema.
                    //
                    // But it miiiiiight be something we could slide by with if
                    // we maintain the invariant that the referenced type may
                    // never change in a backwards-incompatible way. (That's
                    // gonna be absolutely necessary in any referencing
                    // scenario.)
                    fieldConfig: FieldConfigSource
                }
            },
            {
               dashboardFamily.seqs[0][0]
               Dashboard: foo: string  
            }
		]
	]
}

#Latest: {
    #Dashboard: dashboardFamily.latest.Dashboard
    #Panel: dashboardFamily.latest.Panel
}

#SchemaLineage: [{...}, ...{...}]
#LastSchema: {
    _p: #SchemaLineage
    _p[len(_p)-1]
}

// TODO define structures for migrations

#SchemaFamily: {
    // TODO This encodes the idea that schemata are organized into a series of
    // (backwards compatible) lineage sequences, with major and minor versions
    // corresponding to their position in the series of arrays. (i.e. the
    // first schema in the first lineage is 0.0.)
    // 
    // This approach can, and probably should, change. However, any approach 
    // will need to maintain certain properties: 
    //  - Specific versions of a schema can be extracted by querying the family
    //    for with version number
    //  - (Probably) individual schema do not internally define
    //    version fields, but instead rely on this SchemaFamily meta-structure to do it
	seqs: [#SchemaLineage, ...#SchemaLineage]
	let lseq = seqs[len(seqs)-1]
	latest: #LastSchema & { _p: lseq }

    // TODO add migration structures, once defined
}

//  Every property is optional
//  Plugins may extend this with additional  Something like series overrides
FieldConfig: {
	// The display value for this   This supports template variables blank is auto
	displayName?: string

	// This can be used by data sources that return and explicit naming structure for values and labels
	// When this property is configured, this value is used rather than the default naming 
	displayNameFromDS?: string

	// Human readable field metadata
	description?: string

	// An explict path to the field in the   When the frame meta includes a path,
	// This will default to `${metapath}/${name}
	//
	// When defined, this value can be used as an identifier within the datasource scope, and
	// may be used to update the results
	path?: string

	// True if data source can write a value to the   Auth/authz are supported separately
	writeable?: bool

	// True if data source field supports ad-hoc filters
	filterable?: bool

	// Numeric Options
	unit?: string

	// Significant digits (for display)
	decimals?: number | *null
	min?:      number | null
	max?:      number | null

	// Alternative to empty string
	noValue?: string

	// Panel Specific Values
	custom?: {}
} @cuetsy(targetType="interface")

// Defines 
FieldConfigSource: {
	// Defaults applied to all numeric fields
	defaults: FieldConfig

	// Rules to override individual values
	overrides: [ConfigOverrideRule]
} @cuetsy(targetType="interface")
DynamicConfigValue: {
	id: string | *""
	value?: {}
} @cuetsy(targetType="interface")
MatcherConfig: {
	id: string | *""
	options?: {}
} @cuetsy(targetType="interface")
PanelGridPos: {
	// Panel 
	h: int & >0 | *9
	// Panel 
	w: int & >0 & <=24 | *12
	// Panel x 
	x: int & >=0 & <24 | *0
	// Panel y 
	y: int & >=0 | *0
	// true if fixed
	static?: bool
}

ConfigOverrideRule: {
	matcher: MatcherConfig
	properties: [DynamicConfigValue]
} @cuetsy(targetType="interface")
#Panel: {
	// The panel plugin type  
	type: string | *""

	// Panel 
	title?: string
	// 
	description?: string
	// Whether to display the panel without a 
	transparent: bool | *false
	// Name of default 
	datasource?: string
	// Grid 
	gridPos?: PanelGridPos
	// Panel 
	// links?: [_panelLink]
	// Name of template variable to repeat 
	repeat?: string
	// Direction to repeat in if 'repeat' is 
	// "h" for horizontal, "v" for 
	repeatDirection: *"h" | "v"
	// Panel targets - specific values depend on the datasource
	targets?: [{}]

	// The values depend on panel type
	options: {}
	fieldConfig: FieldConfigSource
}
